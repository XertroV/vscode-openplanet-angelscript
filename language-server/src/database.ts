import { getAccPrefix, setAccPrefix } from "./as_parser";
import { ConvertNadeoType, CoreMethod } from "./convert_nadeo";
import { IconNames } from "./icons";
import { MkAsSnippet } from "./parsed_completion";
import { TypeCounter } from "./util/typecounter";

export enum DBAllowSymbol
{
    None = 0,
    All = ~0,

    Properties = 1 << 0,
    Functions = 1 << 1,
    Mixins = 1 << 2,
    Types = 1 << 3,

    PropertiesAndFunctions = Properties | Functions,
    FunctionsAndMixins = Functions | Mixins,
};

function ReplaceArrayShorthand(_type: string): string {
    if (!_type?.includes('[]')) return _type;
    // console.log(`Replacing array shorthand in: ${_type}`);
    return _type.replace(/([A-Za-z_\.:@]+)\[\]/, function(a, b) { return `array<${b}>`; });
    // return _type;
}

export function AllowsFunctions(allowSymbol : DBAllowSymbol)
{
    return (allowSymbol & DBAllowSymbol.Functions) != 0;
}

export function AllowsProperties(allowSymbol : DBAllowSymbol)
{
    return (allowSymbol & DBAllowSymbol.Properties) != 0;
}

export function FilterAllowsSymbol(symbol : DBSymbol, allowSymbol : DBAllowSymbol) : boolean
{
    if (symbol instanceof DBProperty)
    {
        if ((allowSymbol & DBAllowSymbol.Properties) != 0)
            return true;
    }
    else if (symbol instanceof DBMethod)
    {
        if (symbol.isMixin)
        {
            if ((allowSymbol & DBAllowSymbol.Mixins) != 0)
                return true;
        }
        else
        {
            if ((allowSymbol & DBAllowSymbol.Functions) != 0)
                return true;
        }
    }
    else if (symbol instanceof DBType)
    {
        if ((allowSymbol & DBAllowSymbol.Types) != 0)
            return true;
    }

    return false;
}

export enum DBTypeClassification
{
    Unknown,
    Other,
    // Component,
    // Actor,
    // Struct,
    // Event,
    // Delegate,
    Primitive
};

export interface DBSymbol
{
    name : string;
    containingType : DBType;
    namespace : DBNamespace;
    keywords : Array<string>;
    declaredModule : string | null;
    auxiliarySymbols : Array<DBAuxiliarySymbol> | null;
    class_name : string;
};

export interface DBAuxiliarySymbol
{
    symbol_name : string;
    container_type : string;
};

export class DBProperty implements DBSymbol
{
    class_name = "DBProperty";
    name : string;
    typename : string;
    documentation : string;
    isProtected : boolean = false;
    isPrivate : boolean = false;
    isNoEdit : boolean = false;
    isEditOnly : boolean = false;
    isAutoGenerated : boolean = false;
    isLiteralAsset : boolean = false;

    accessSpecifier : DBAccessSpecifier = null;
    declaredModule : string | null;
    moduleOffset : number;
    moduleOffsetEnd : number = -1;

    containingType : DBType = null;
    namespace : DBNamespace = null;
    keywords : Array<string> = null;

    // isUProperty : boolean = false;
    macroSpecifiers : Map<string, string> = null;
    macroMeta : Map<string, string> = null;
    auxiliarySymbols : Array<DBAuxiliarySymbol> | null = null;

    fromJSON(input : any)
    {
        this.name = input.name;
        this.typename = input.typedecl;
        this.documentation = input.desc;
        this.isProtected = false;
        this.isPrivate = false;
        this.isNoEdit = false;
        this.isEditOnly = false;

        // let flags : number = 0;
        // for (let i = 1; i < input.length; ++i)
        // {
        //     if (typeof input[i] == 'string')
        //     {
        //         if (input[i] == "NoEdit")
        //             flags |= 1;
        //         else if (input[i] == "EditOnly")
        //             flags |= 2;
        //         else
        //             this.documentation = FormatDocumentationComment(input[i]);
        //     }
        //     else if (typeof input[i] == 'number')
        //     {
        //         flags = input[i];
        //     }
        // }

        // if (flags & 0x1)
        //     this.isNoEdit = true;
        // if (flags & 0x2)
        //     this.isEditOnly = true;
        // if (flags & 0x4)
        //     this.isProtected = true;
    }

    format(prefix : string = null) : string
    {
        let str : string = "";
        if (this.isProtected)
            str += "protected ";
        if (this.isPrivate)
            str += "private ";
        str += this.typename;
        str += " ";
        if (prefix)
            str += prefix;
        str += this.name;
        return str;
    }

    createTemplateInstance(templateTypes : Array<string>, actualTypes : Array<string>) : DBProperty
    {
        let inst = new DBProperty();
        inst.name = this.name;
        inst.typename = ReplaceTemplateType(this.typename, templateTypes, actualTypes);
        return inst;
    }
};

export class DBArg
{
    name : string | null;
    typename : string;
    defaultvalue : string | null;

    init(typename : string, name : string, defaultvalue : string = "") : DBArg
    {
        this.name = name;
        this.typename = typename;
        if (defaultvalue)
            this.defaultvalue = defaultvalue;
        return this;
    }

    fromJSON(input : any)
    {
        this.name = 'name' in input ? input['name'] : null;
        this.typename = ReplaceArrayShorthand(input['typedecl']);
        this.defaultvalue = 'default' in input ? input['default'] : null;
    }

    format() : string
    {
        let decl = this.typename;
        if (this.name != null)
            decl += " " + this.name;
        if (this.defaultvalue != null)
            decl += " = " + this.defaultvalue;
        return decl;
    }

    createTemplateInstance(templateTypes : Array<string>, actualTypes : Array<string>) : DBArg
    {
        let inst = new DBArg();
        inst.name = this.name;
        inst.defaultvalue = this.defaultvalue;
        inst.typename = ReplaceTemplateType(this.typename, templateTypes, actualTypes);
        return inst;
    }
};

export enum DBMethodAnnotation
{
    None,
    IsHexColor,
    IsLinearColor,
};

export class DBMethod implements DBSymbol
{
    class_name = "DBMethod";
    name : string;
    returnType : string;
    args : Array<DBArg>;
    argumentStr : string;
    documentation : string;
    isProtected : boolean = false;
    isPrivate : boolean = false;
    isConstructor : boolean = false;
    isBlueprintEvent: boolean = false; // unreal?
    isBlueprintOverride: boolean = false; // unreal?
    isConst : boolean = false;
    isFinal : boolean = false;
    isProperty : boolean = false;
    isOverride : boolean = false;
    isDefaultsOnly : boolean = false;
    isLocal : boolean = false;
    id : number = NextMethodId++;
    containingType : DBType = null;
    ns : string;
    namespace : DBNamespace = null;
    keywords : Array<string> = null;
    isAutoGenerated : boolean = false;
    isMixin : boolean = false;
    accessSpecifier : DBAccessSpecifier = null;
    auxiliarySymbols : Array<DBAuxiliarySymbol> | null = null;

    isUFunction : boolean = false; // unreal
    macroSpecifiers : Map<string, string> = null;
    macroMeta : Map<string, string> = null;

    hasSuperCall : boolean = false;
    isEmpty : boolean = false;

    isDelegateBindFunction : boolean = false;
    delegateBindType : string = null;
    delegateObjectParam : number = -1;
    delegateFunctionParam : number = -1;

    methodAnnotation : DBMethodAnnotation = DBMethodAnnotation.None;

    declaredModule : string;
    moduleOffset : number;
    moduleOffsetEnd : number = -1;
    moduleScopeStart : number = -1;
    moduleScopeEnd : number = -1;

    suggestionDecl?: string;
    isImported: boolean = false;

    nameNoAccessor(): string {
        if (this.name.startsWith(getAccPrefix) || this.name.startsWith(setAccPrefix)) {
            return this.name.substring(getAccPrefix.length);
        }
        return this.name;
    }

    createTemplateInstance(templateTypes : Array<string>, actualTypes : Array<string>) : DBMethod
    {
        let inst = new DBMethod();
        inst.name = this.name;
        inst.returnType = ReplaceTemplateType(this.returnType, templateTypes, actualTypes);
        inst.argumentStr = this.argumentStr;
        inst.documentation = this.documentation;
        inst.isProtected = this.isProtected;
        inst.isPrivate = this.isPrivate;
        inst.isConstructor = this.isConstructor;
        inst.isBlueprintEvent = this.isBlueprintEvent;
        inst.isBlueprintOverride = this.isBlueprintOverride;
        inst.isConst = this.isConst;
        inst.isProperty = this.isProperty;
        inst.isDefaultsOnly = this.isDefaultsOnly;

        inst.args = [];
        for(let argval of this.args)
            inst.args.push(argval.createTemplateInstance(templateTypes, actualTypes));
        return inst;
    }

    /**
     *
     * @param input {name: string, returntypedecl?: string, args: <DBArg.fromJSON>[], decl?: string, desc?: string, ns?: string, const?: bool, (and others)}
     */
    fromJSON(input : any)
    {
        this.name = input.name;

        if ('returntypedecl' in input)
            this.returnType = ReplaceArrayShorthand(input.returntypedecl);
        else
            this.returnType = 'void';

        this.args = new Array<DBArg>();
        if ('args' in input)
        {
            for (let argDesc of input['args'])
            {
                let arg = new DBArg;
                arg.fromJSON(argDesc);

                this.args.push(arg);
            }
        }

        if ('desc' in input)
            this.documentation = FormatDocumentationComment(input['desc']);
        else
            this.documentation = null;

        this.isConstructor = input['name'] == "$beh0";
        if (this.isConstructor) {
            this.name = input['decl'].split("(")[0]; // "Blah(...)" -> "Blah"
        }

        // if ('ns' in input)
        //     this.ns = input.ns;

        this.namespace = RootNamespace;
        if ('ns' in input && input.ns.length > 0) {
            this.ns = input['ns'];
            this.namespace = LookupNamespace(null, this.ns);
            if (!this.namespace) {
                this.namespace = DeclareNamespace(null, this.ns, new DBNamespaceDeclaration());
            }
        }

        // todo: is this about return type or const methods?
        if ('const' in input)
            this.isConst = input['const'];
        else
            this.isConst = false;

        this.isProperty = this.name.startsWith(getAccPrefix) || this.name.startsWith(setAccPrefix);

        if ('protected' in input)
            this.isProtected = input['protected'];
        else
            this.isProtected = false;

        if ('defaultsonly' in input)
            this.isDefaultsOnly = input['defaultsonly'];

        if ('keywords' in input)
            this.keywords = input['keywords'];

        // if ('meta' in input)
        // {
        //     if (!this.macroMeta)
        //         this.macroMeta = new Map<string, string>();
        //     for (let metaSpec in input['meta'])
        //         this.macroMeta.set(metaSpec.toLowerCase(), input['meta'][metaSpec]);
        //     this.cacheDelegateMeta();
        // }

        if ('decl' in input) this.suggestionDecl = input['decl'];
    }

    cacheDelegateMeta()
    {
        if (!this.macroMeta)
            return;

        if (this.macroMeta.has("delegatefunctionparam")
            && this.macroMeta.has("delegateobjectparam")
            && this.macroMeta.has("delegatebindtype"))
        {
            this.isDelegateBindFunction = true;
            this.delegateBindType = this.macroMeta.get("delegatebindtype");

            let functionParam = this.macroMeta.get("delegatefunctionparam");
            let objectParam = this.macroMeta.get("delegateobjectparam");

            for (let i = 0, count = this.args.length; i < count; ++i)
            {
                if (this.args[i].name == objectParam)
                    this.delegateObjectParam = i;
                else if (this.args[i].name == functionParam)
                    this.delegateFunctionParam = i;
            }

        }
    }

    format(prefix : string = null, skipFirstArg = false, skipReturn = false, replaceName : string = null) : string
    {
        let decl : string = "";
        if (!skipReturn)
            decl += this.returnType + " ";
        if(prefix != null)
            decl += prefix;
        if (replaceName)
            decl += replaceName + "(";
        else
            decl += this.name + "(";
        let firstArg = true;
        if (this.argumentStr)
        {
            let argStr = this.argumentStr;
            if (skipFirstArg)
            {
                let cPos = argStr.search(",");
                if(cPos != -1)
                    argStr = argStr.substring(cPos+1).trim();
                else
                    argStr = "";
            }
            decl += argStr;
        }
        else if(this.args)
        {
            for(let i = 0; i < this.args.length; ++i)
            {
                if (skipFirstArg && i == 0)
                    continue;

                if (i > 0 || (skipFirstArg && i > 1))
                    decl += ", ";
                decl += this.args[i].format();
            }
        }
        decl += ")";
        if (this.isConst)
            decl += " const";
        if (this.isProperty && this.declaredModule)
            decl += " property";
        return decl;
    }

    // Get documentation either from this function or from the
    // first parent function we're overriding
    findAvailableDocumentation(includeParent = true, includeType = true) : string
    {
        if (this.documentation)
            return this.documentation;
        // Use the parent function's documentation
        if (this.containingType && includeParent)
        {
            for (let checktype of this.containingType.getInheritanceTypes())
            {
                let parentFunc = checktype.findFirstSymbol(this.name, DBAllowSymbol.Functions);
                if (parentFunc && parentFunc instanceof DBMethod && parentFunc.documentation)
                    return parentFunc.documentation;
            }
        }
        // Use the type's documentation for constructors
        if (this.isConstructor && includeType)
        {
            let dbReturn = LookupType(this.namespace, this.returnType);
            if (dbReturn && dbReturn instanceof DBType && dbReturn.documentation)
                return dbReturn.documentation;
        }
        return null;
    }

    hasMetaData(meta : string) : boolean
    {
        if (!this.macroMeta)
            return false;
        return this.macroMeta.has(meta.toLowerCase());
    }

    getRequiredArgumentCount() : number
    {
        if (!this.args)
            return 0;
        for (let i = 0, argCount = this.args.length; i < argCount; ++i)
        {
            if (this.args[i].defaultvalue)
                return i;
        }
        return this.args.length;
    }

    isSignatureEqual(otherFunc : DBMethod) : boolean
    {
        if ((!!this.args) != (!!otherFunc.args))
            return false;

        if (this.isConst != otherFunc.isConst)
            return false;

        if (this.args)
        {
            if (this.args.length != otherFunc.args.length)
                return false;
            for (let i = 0, argCount = this.args.length; i < argCount; ++i)
            {
                if (this.args[i].typename != otherFunc.args[i].typename)
                    return false;
            }
        }

        if (this.returnType != otherFunc.returnType)
            return false;

        return true;
    }

    IsAccessibleFromModule(module : string) : boolean
    {
        if (this.isLocal)
        {
            if (this.declaredModule && this.declaredModule != module)
                return false;
        }

        return true;
    }

    getSignature(): string {
        return `${this.returnType} ${this.name}(${this.args.map(a => `${a.typename} ${a.name}`).join(", ")})`
    }

    private funcType?: DBType;
    getFuncType(): DBType {
        if (!this.funcType) {
            let funcType = new DBType;
            funcType.name = this.name;
            funcType.classification = DBTypeClassification.Other;
            funcType.declaredModule = this.declaredModule;
            funcType.moduleOffset = this.moduleOffset;
            funcType.moduleOffsetEnd = this.moduleOffsetEnd;
            funcType.moduleScopeEnd = this.moduleScopeEnd;
            funcType.moduleScopeStart = this.moduleScopeStart;
            funcType.namespace = this.namespace;
            funcType.delegateArgs = this.args;
            funcType.delegateReturn = this.returnType;
            funcType.isDelegate = true;
            funcType.delegateSource = this;
            funcType.documentation = FormatDocumentationComment(MkAsSnippet(`funcdef ` + this.format() + ';'));
            this.funcType = funcType;
            // if (this.namespace.findSymbols(this.name, DBAllowSymbol.Types).length == 0)
            AddTypeToDatabase(this.namespace, funcType);
        }
        return this.funcType;
    }

    private funcDefApplier?: DBMethod;
    asFuncDefApplier(): DBSymbol {
        if (!this.funcDefApplier) {
            this.funcDefApplier = new DBMethod;
            this.funcDefApplier.fromJSON({name: this.name, returntypedecl: this.name + "@", args: [{name: "func", typedecl: "Function@"}]});
            this.funcDefApplier.documentation = FormatDocumentationComment(MkAsSnippet(`funcdef ` + this.format() + ';'));
        }
        return this.funcDefApplier;
    }
};

export class DBType implements DBSymbol
{
    class_name = "DBType";
    typeid : number = -1;
    name : string;
    supertype : string;
    supertypes : string[];
    // unrealsuper : string;
    documentation : string;
    namespace : DBNamespace;
    ns : string;

    isStruct : boolean;
    isEnum : boolean;
    isDelegate : boolean = false;
    isEvent : boolean = false;
    isPrimitive : boolean = false;
    isTemplateInstantiation : boolean = false;
    isShared : boolean = false;
    isMixin : boolean = false;
    isInterface : boolean = false;
    isAbstract : boolean = false;

    classification : DBTypeClassification = DBTypeClassification.Unknown;
    acccessSpecifiers : Array<DBAccessSpecifier> = null;

    keywords : Array<string> = null;
    macroSpecifiers : Map<string, string> = null;
    macroMeta : Map<string, string> = null;

    delegateArgs: Array<DBArg> = null; // unreal?
    delegateReturn: string = null; // unreal?
    delegateSource?: DBMethod;

    declaredModule : string;
    moduleOffset : number;
    moduleOffsetEnd : number = -1;
    moduleScopeStart : number = -1;
    moduleScopeEnd : number = -1;

    templateSubTypes : Array<string>;

    symbols = new Map<string, DBSymbol | Array<DBSymbol>>();
    symbolsByPrefix = new Map<string, Array<DBSymbol>>();

    containingType : DBType = null;
    auxiliarySymbols : Array<DBAuxiliarySymbol> | null = null;

    constructor(kind : string = "") {
        if (kind == "enums")
            this.isEnum = true;
    }

    createTemplateInstance(actualTypes : Array<string>) : DBType
    {
        if (actualTypes.length != this.templateSubTypes?.length)
            return null;

        let oldSubtypes = this.templateSubTypes;
        let inst = new DBType();
        inst.name = this.name.replace(`<${oldSubtypes.join(', ')}>`, `<${actualTypes.join(", ")}>`);
        inst.supertype = this.supertype;
        inst.supertypes = this.supertypes;
        inst.isEnum = this.isEnum;
        inst.declaredModule = this.declaredModule;
        inst.moduleOffset = this.moduleOffset;
        inst.moduleOffsetEnd = this.moduleOffsetEnd;
        inst.isTemplateInstantiation = true;
        inst.templateSubTypes = actualTypes;

        let baseType = this;
        this.forEachSymbol(function (sym : DBSymbol)
        {
            if (sym instanceof DBProperty)
            {
                let newProp = sym.createTemplateInstance(baseType.templateSubTypes, actualTypes);
                inst.addSymbol(newProp);
            }
            else if (sym instanceof DBMethod)
            {
                let newMethod = sym.createTemplateInstance(baseType.templateSubTypes, actualTypes);
                inst.addSymbol(newMethod);
            }
        });

        return inst;
    }

    initEmpty(name : string) : DBType
    {
        this.name = name;
        return this;
    }

    fromJSON(input : any)
    {
        this.name = input['name'];

        this.namespace = RootNamespace;
        if ('ns' in input && input.ns?.length > 0){
            this.ns = input['ns'];
            this.namespace = LookupNamespace(null, this.ns);
            if (!this.namespace) {
                this.namespace = DeclareNamespace(null, this.ns, new DBNamespaceDeclaration());
            }
        }

        if ('isEnum' in input)
            this.isEnum = input['isEnum'];

        if (!this.isEnum) {
            input.props.forEach((_prop: any) => {
                let prop = new DBProperty();
                prop.fromJSON(_prop);
                this.addSymbol(prop);
            });
            input.methods.forEach((method: any) => {
                let func = new DBMethod();
                func.fromJSON(method);
                this.addSymbol(func);
            });
            // input.behaviors.forEach((behavior: any) => {
            // })
        } else {
            for(let v in input.values) {
                let val = new DBProperty();
                val.name = v;
                val.typename = this.name; // (this.ns ? (this.ns + "::") : "") + // todo: look for render name function
                this.addSymbol(val);
            }
        }

        if ('subtypes' in input)
        {
            this.templateSubTypes = new Array<string>();
            for(let subtype of input['subtypes'])
            {
                this.templateSubTypes.push(subtype);
            }
        }

        // if ('supertype' in input)
        // {
        //     this.unrealsuper = input['supertype'];
        // }

        if ('inherits' in input)
        {
            this.supertype = input['inherits'];
            this.supertypes = [input['inherits']];
        }

        if ('desc' in input)
            this.documentation = FormatDocumentationComment(input['desc']);
        else
            this.documentation = null;

        if ('keywords' in input)
            this.keywords = input['keywords'];

        if ('isStruct' in input)
            this.isStruct = input['isStruct'];
        else
            this.isStruct = false;

        let delegateSignatureMethod : DBSymbol = null;
        if ('isEvent' in input)
        {
            this.isEvent = input['isEvent'];
            if (this.isEvent)
                delegateSignatureMethod = this.findFirstSymbol("Broadcast");
        }
        else
        {
            delegateSignatureMethod = this.findFirstSymbol("Broadcast");
            this.isEvent = delegateSignatureMethod != null;
        }

        if ('isDelegate' in input)
        {
            this.isDelegate = input['isDelegate'];
            if (this.isDelegate)
                delegateSignatureMethod = this.findFirstSymbol("ExecuteIfBound");
        }
        else
        {
            if (!this.isEvent)
            {
                delegateSignatureMethod = this.findFirstSymbol("ExecuteIfBound");
                this.isDelegate = delegateSignatureMethod != null;
            }
            else
            {
                this.isDelegate = false;
            }
        }

        if (delegateSignatureMethod != null && delegateSignatureMethod instanceof DBMethod)
        {
            // Detect the signature for the delegate from the Broadcast or ExecuteIfBound methods
            this.delegateArgs = delegateSignatureMethod.args;
            this.delegateReturn = delegateSignatureMethod.returnType;

            // Mark the Add/Bind/Unbind functions so diagnostics can see them
            let bindFuncs: DBSymbol[] = [];
            if (this.isEvent)
                bindFuncs = [this.findFirstSymbol("AddUFunction"), this.findFirstSymbol("Unbind")];
            else
                bindFuncs = [this.findFirstSymbol("BindUFunction")];

            bindFuncs.forEach((bindFunc: DBSymbol) => {
                if (bindFunc instanceof DBMethod)
                {
                    bindFunc.isDelegateBindFunction = true;
                    bindFunc.delegateBindType = this.name;
                    bindFunc.delegateObjectParam = 0;
                    bindFunc.delegateFunctionParam = 1;
                }
            });
        }
    }

    getDisplayName() : string
    {
        return this.name;
    }

    isTemplateType() : boolean
    {
        return this.templateSubTypes && this.templateSubTypes.length != 0;
    }

    getSuperType() : DBType
    {
        if (!this.supertype)
            return null;
        // console.warn(`getSuperType(): ${this.supertype} -- found: ${LookupType(this.namespace, this.supertype)?.name}`);
        // console.trace('supertype call')
        return LookupType(this.namespace, this.supertype);
    }

    equalsTypename(typename : string) : boolean
    {
        if (typename == this.name)
            return true;
        let cleaned = CleanTypeName(typename);
        if (cleaned == this.name)
            return true;
        return false;
    }

    isUnrealType() : boolean
    {
        return !this.declaredModule;
    }

    hasExtendTypes() : boolean
    {
        if(this.supertype)
            return true;
        return false;
    }

    extendTypes : Array<DBType> = null;
    extendTypesId : number = -1;
    getExtendTypesList() : Array<DBType>
    {
        if (this.extendTypes)
        {
            if (this.extendTypesId == DirtyTypeCacheId)
                return this.extendTypes;
        }

        this.extendTypes = [ this ];
        this.extendTypesId = DirtyTypeCacheId;
        let checkIndex = 0;
        while (checkIndex < this.extendTypes.length)
        {
            let checkType = this.extendTypes[checkIndex];

            if (checkType.supertypes)
            {
                for (let st of checkType.supertypes) {
                    let dbsuper = LookupType(checkType.namespace, st);
                    if(dbsuper && !this.extendTypes.includes(dbsuper))
                        this.extendTypes.push(dbsuper);
                }
            }

            checkIndex += 1;
        }

        return this.extendTypes;
    }

    formatDelegateSignature() : string
    {
        let decl : string = "";
        if (this.delegateReturn)
            decl += this.delegateReturn + " ";
        decl += this.name + "(";
        if(this.delegateArgs)
        {
            for(let i = 0; i < this.delegateArgs.length; ++i)
            {
                if (i > 0)
                    decl += ", ";
                decl += this.delegateArgs[i].format();
            }
        }
        decl += ")";
        return decl;
    }

    getProperty(name : string, recurseSuper : boolean = true) : DBProperty | null
    {
        if (!recurseSuper || !this.hasExtendTypes())
        {
            let prop = this.findFirstSymbol(name, DBAllowSymbol.Properties);
            if (prop instanceof DBProperty)
                return prop;
        }
        else
        {
            for (let extendType of this.getExtendTypesList())
            {
                let prop = extendType.findFirstSymbol(name, DBAllowSymbol.Properties);
                if (prop instanceof DBProperty)
                    return prop;
            }
        }

        return null;
    }

    getMethod(name : string, recurseSuper : boolean = true) : DBMethod | null
    {
        if (!recurseSuper || !this.hasExtendTypes())
        {
            let method = this.findFirstSymbol(name, DBAllowSymbol.Functions);
            if (method instanceof DBMethod)
                return method;
        }
        else
        {
            for (let extendType of this.getExtendTypesList())
            {
                let method = extendType.findFirstSymbol(name, DBAllowSymbol.Functions);
                if (method instanceof DBMethod)
                    return method;
            }
        }

        return null;
    }

    getMethodWithIdHint(name : string, id : number, recurseSuper = true) : DBMethod | null
    {
        let fallback : DBMethod = null;

        let method = this.findFirstSymbol(name, DBAllowSymbol.Functions);
        if (method instanceof DBMethod)
        {
            if (method.id == id)
                return method;
            else
                fallback = method;
        }

        if (!recurseSuper)
            return fallback;

        if (!this.hasExtendTypes())
            return fallback;

        for (let extend of this.getExtendTypesList())
        {
            if (extend == this)
                continue;
            let extendMethod = extend.getMethodWithIdHint(name, id, false);
            if (extendMethod)
            {
                if (extendMethod.id == id)
                    return extendMethod;
                else if (!fallback)
                    fallback = extendMethod;
            }
        }

        return fallback;
    }

    inheritsFrom(checktype : string) : boolean
    {
        let it : DBType = this;
        let dbCheck : DBType = LookupType(this.namespace, checktype);
        if(!dbCheck)
            return false;
        let _inheritsFrom = (it: DBType, depth: number): {found: boolean, depth: number} => {
            if (!it || depth > 100) return {found: false, depth};
            if (it == dbCheck) return {found: true, depth};
            if (!it.supertypes) return {found: false, depth};
            let notFoundRet = {found: false, depth: depth + 1};
            for (let stName of it.supertypes) {
                let st = LookupType(it.namespace, stName);
                if (!st) continue;
                let stInheritsFrom = _inheritsFrom(st, depth + 1);
                if (stInheritsFrom.found) {
                    return stInheritsFrom;
                } else {
                    notFoundRet = stInheritsFrom;
                }
            }
            return notFoundRet;
        };
        return _inheritsFrom(it, 0).found;
        // let depth = 0;
        // while(it && depth < 100)
        // {
        //     if (it == dbCheck)
        //         return true;

        //     if (it.supertype)
        //     {
        //         it = LookupType(it.namespace, it.supertype);
        //         depth += 1;
        //         continue;
        //     }
        //     // else if (it.unrealsuper)
        //     // {
        //     //     it = LookupType(it.namespace, it.unrealsuper);
        //     //     depth += 1;
        //     //     continue;
        //     // }
        //     else
        //     {
        //         break;
        //     }
        // }
        // return false;
    }

    isValueType() : boolean
    {
        if (this.isPrimitive)
            return true;
        if (this.isStruct)
            return true;
        if (this.isEnum)
            return true;
        return false;
    }

    getInheritanceTypes() : Array<DBType>
    {
        let typeList = new Array<DBType>();
        typeList.push(this); // remove later
        let ix = 0;
        let check : DBType = this;
        while (ix < typeList.length)
        {
            check = typeList[ix];
            if (check.supertypes) {
                for (let stName of check.supertypes) {
                    let st = LookupType(check.namespace, stName);
                    if (!st) continue;
                    if (typeList.includes(st)) continue;
                    typeList.push(st);
                }
            }
            ix += 1;
        }
        // return typeList.slice(1);
        return typeList;
    }

    canOverrideFromParent(methodname : string) : boolean
    {
        let allSTs = this.getInheritanceTypes();
        for (let st of allSTs) {
            let method = st.getMethod(methodname, false);
            if (method) {
                return true;
            }
        }
        return false;
        // Check script parents
        let checktype = this.supertype;
        let depth = 0;
        while (checktype && depth < 100)
        {
            let dbsuper = LookupType(this.namespace, checktype);
            if (!dbsuper)
                break;
            let method = dbsuper.getMethod(methodname, false);
            if (method)
            {
                if (!dbsuper.isUnrealType() || method.isBlueprintEvent)
                    return true;
            }
            checktype = dbsuper.supertype;
            depth += 1;
        }

        return false;
    }

    forEachSymbol(func : (symbol : DBSymbol) => void, recurseSuper = true)
    {
        if (!recurseSuper || !this.hasExtendTypes())
        {
            for (let [_, syms] of this.symbols)
            {
                if (syms instanceof Array)
                {
                    for (let sym of syms)
                        func(sym);
                }
                else
                {
                    func(syms);
                }
            }
        }
        else
        {
            for (let extendType of this.getExtendTypesList())
            {
                for (let [_, syms] of extendType.symbols)
                {
                    if (syms instanceof Array)
                    {
                        for (let sym of syms)
                            func(sym);
                    }
                    else
                    {
                        func(syms);
                    }
                }
            }
        }
    }

    findFirstSymbol(name : string, allowSymbols = DBAllowSymbol.All) : DBSymbol | null
    {
        for (let type of this.getExtendTypesList())
        {
            let syms = type.symbols.get(name);
            if (syms instanceof Array)
            {
                for (let sym of syms)
                {
                    if (FilterAllowsSymbol(sym, allowSymbols))
                        return sym;
                }
            }
            else
            {
                if (FilterAllowsSymbol(syms, allowSymbols))
                    return syms;
            }
        }

        return null;
    }

    // NOTE: Prefix must be at least 2 characters
    findFirstSymbolWithPrefix(prefix : string, allowSymbols = DBAllowSymbol.All, caseSensitive = true, depth = 100) : DBSymbol | null
    {
        if (prefix.length < 2)
            return null;

        let charPrefix = prefix.substring(0, 2).toLowerCase();
        for (let type of this.getExtendTypesList())
        {
            let syms = type.symbolsByPrefix.get(charPrefix);
            if (syms && syms.length != 0)
            {
                for (let sym of syms)
                {
                    if (!FilterAllowsSymbol(sym, allowSymbols))
                        continue;

                    if (caseSensitive)
                    {
                        if (sym.name.startsWith(prefix))
                            return sym;
                    }
                    else
                    {
                        if (sym.name.toLowerCase().startsWith(prefix.toLowerCase()))
                            return sym;
                    }
                }
            }
        }

        return null;
    }

    findSymbols(name : string) : Array<DBSymbol>
    {
        let result : Array<DBSymbol> = [];
        for (let type of this.getExtendTypesList())
        {
            let syms = type.symbols.get(name);
            if (syms instanceof Array)
            {
                for (let sym of syms)
                {
                    result.push(sym);
                }
            }
            else
            {
                result.push(syms);
            }
        }
        return result;
    }

    addSymbol(symbol : DBSymbol)
    {
        symbol.containingType = this;
        symbol.namespace = this.namespace;

        {
            let syms = this.symbols.get(symbol.name);
            if (!syms)
            {
                this.symbols.set(symbol.name, symbol);
            }
            else if (syms instanceof Array)
            {
                syms.push(symbol);
            }
            else
            {
                this.symbols.set(symbol.name, [symbol, syms]);
            }
        }

        if (symbol.name.length > 2)
        {
            let prefix = symbol.name.substring(0, 2).toLowerCase();
            let prefixSyms = this.symbolsByPrefix.get(prefix);
            if (!prefixSyms)
            {
                prefixSyms = new Array<DBSymbol>();
                this.symbolsByPrefix.set(prefix, prefixSyms);
            }

            prefixSyms.push(symbol);
        }
    }

    removeSymbol(symbol : DBSymbol)
    {
        {
            let syms = this.symbols.get(symbol.name);
            if (syms)
            {
                if (syms == symbol)
                {
                    this.symbols.delete(symbol.name);
                }
                else if (syms instanceof Array)
                {
                    let index = syms.indexOf(symbol);
                    if (index != -1)
                        syms.splice(index, 1);
                }
            }
        }

        if (symbol.name.length > 2)
        {
            let prefix = symbol.name.substring(0, 2).toLowerCase();
            let prefixSyms = this.symbolsByPrefix.get(prefix);
            if (prefixSyms)
            {
                let index = prefixSyms.indexOf(symbol);
                if (index != -1)
                    prefixSyms.splice(index, 1);
            }
        }
    }

    getTypeClassification() : DBTypeClassification
    {
        if (this.classification == DBTypeClassification.Unknown)
        {
            // if (this.isDelegate)
            //     this.classification = DBTypeClassification.Delegate;
            // else if (this.isEvent)
            //     this.classification = DBTypeClassification.Event;
            // else if (this.isStruct)
            //     this.classification = DBTypeClassification.Struct;
            if (this.isPrimitive)
                this.classification = DBTypeClassification.Primitive;
            else
                this.classification = DBTypeClassification.Other;
        }
        return this.classification;
    }

    getAccessSpecifier(name : string, create = true) : DBAccessSpecifier | null
    {
        if (this.acccessSpecifiers)
        {
            for (let spec of this.acccessSpecifiers)
            {
                if (spec.name == name)
                    return spec;
            }
        }

        if (create)
        {
            let spec = new DBAccessSpecifier();
            spec.name = name;
            spec.declaredType = this.name;

            if (this.acccessSpecifiers)
                this.acccessSpecifiers.push(spec);
            else
                this.acccessSpecifiers = [spec];

            return spec;
        }

        return null;
    }

    getQualifiedTypenameInNamespace(accessNamespace : DBNamespace) : string
    {
        if (!this.namespace || this.namespace.isRootNamespace())
            return this.name;
        // todo: bug `MLHook::array<PlayerCpInfo>`
        let typename = this.namespace.getQualifiedNamespace() + "::" + this.name;
        if (this.isTemplateType())
            typename = this.createTemplateInstance([CleanTypeName(this.templateSubTypes[0])]).name;
        //     typename = this.createTemplateInstance([this.namespace.getQualifiedNamespace() + "::" + this.templateSubTypes[0]]).name;
        if (accessNamespace && !accessNamespace.isRootNamespace())
        {
            let accessPrefix = accessNamespace.getQualifiedNamespace() + "::";
            if (typename.startsWith(accessPrefix))
                typename = typename.substring(accessPrefix.length);
        }
        return typename;
    }
};

export class DBNamespaceDeclaration
{
    declaredModule : string;
    declaredOffset : number;
    declaredOffsetEnd : number;
    scopeOffsetStart : number;
    scopeOffsetEnd : number;
    isNestedParent : boolean = false;
}

export class DBNamespace
{
    name : string = "";
    documentation : string;
    qualifiedNamespace : string | null = null;

    parentNamespace : DBNamespace | null = null;

    childNamespaces = new Map<string, DBNamespace>();
    childNamespacesByPrefix = new Map<string, Array<DBNamespace>>();

    symbols = new Map<string, DBSymbol | Array<DBSymbol>>();
    symbolsByPrefix = new Map<string, Array<DBSymbol>>();

    declarations = new Array<DBNamespaceDeclaration>();

    // Get the full namespace starting at the root
    getQualifiedNamespace() : string
    {
        if (this.qualifiedNamespace !== null)
            return this.qualifiedNamespace;

        this.qualifiedNamespace = this.name;

        let checkParent = this.parentNamespace;
        while (checkParent)
        {
            if (!checkParent.isRootNamespace())
                this.qualifiedNamespace = checkParent.name + "::" +this.qualifiedNamespace;
            checkParent = checkParent.parentNamespace;
        }

        return this.qualifiedNamespace;
    }

    // Whether this namespace shadows a declared type
    isShadowingType() : boolean
    {
        if (!this.parentNamespace)
            return false;
        if (this.parentNamespace.findFirstSymbol(this.name, DBAllowSymbol.Types))
            return true;
        return false;
    }

    // Get which type this namespace is shadowing
    getShadowedType() : DBType | null
    {
        if (!this.parentNamespace)
            return null;
        let sym = this.parentNamespace.findFirstSymbol(this.name, DBAllowSymbol.Types);
        if (sym instanceof DBType)
            return sym;
        return null;
    }

    isRootNamespace() : boolean
    {
        return this.parentNamespace === null;
    }

    isChildNamespaceOf(parent : DBNamespace) : boolean
    {
        let checkNamespace : DBNamespace = this;
        while (checkNamespace)
        {
            if (checkNamespace == parent)
                return true;
            checkNamespace = checkNamespace.parentNamespace;
        }
        return false;
    }

    forEachSymbol(func : (symbol : DBSymbol) => void)
    {
        for (let [_, syms] of this.symbols)
        {
            if (syms instanceof Array)
            {
                for (let sym of syms)
                    func(sym);
            }
            else
            {
                func(syms);
            }
        }
    }

    GetTypeByName(name: string): DBType | null {
        let syms = this.findSymbols(name, DBAllowSymbol.Types | DBAllowSymbol.Functions);
        if (!syms || syms.length == 0) return;
        // return non-delegate types first
        for (let sym of syms) {
            if (sym instanceof DBType && !sym.isDelegate)
               return sym
        }
        // delegate types
        for (let sym of syms) {
            if (sym instanceof DBType)
               return sym
        }
        // only return methods if we don't have any other options
        for (let sym of syms) {
            if (sym instanceof DBMethod) {
                return sym.getFuncType()
            }
        }
    }

    findFirstSymbol(name : string, allowSymbols : DBAllowSymbol = DBAllowSymbol.All) : DBSymbol | null
    {
        let syms = this.symbols.get(name);
        if (syms instanceof Array)
        {
            for (let sym of syms)
            {
                if (FilterAllowsSymbol(sym, allowSymbols))
                    return sym;
            }
        }
        else
        {
            if (FilterAllowsSymbol(syms, allowSymbols))
                return syms;
        }

        return null;
    }

    findFirstSymbolWithPrefix(prefix : string, allowSymbols : DBAllowSymbol = DBAllowSymbol.All, caseSensitive = true) : DBSymbol | null
    {
        if (prefix.length < 2)
            return null;

        let charPrefix = prefix.substring(0, 2).toLowerCase();
        let syms = this.symbolsByPrefix.get(charPrefix);
        if (syms && syms.length != 0)
        {
            for (let sym of syms)
            {
                if (!FilterAllowsSymbol(sym, allowSymbols))
                    continue;

                if (caseSensitive)
                {
                    if (sym.name.startsWith(prefix))
                        return sym;
                }
                else
                {
                    if (sym.name.toLowerCase().startsWith(prefix.toLowerCase()))
                        return sym;
                }
            }
        }

        return null;
    }

    findSymbols(name : string, allowSymbol : DBAllowSymbol = DBAllowSymbol.All) : Array<DBSymbol>
    {
        let result : Array<DBSymbol> = [];
        let syms = this.symbols.get(name);
        if (syms instanceof Array)
        {
            for (let sym of syms)
            {
                if (FilterAllowsSymbol(sym, allowSymbol))
                    result.push(sym);
            }
        }
        else
        {
            if (FilterAllowsSymbol(syms, allowSymbol))
                result.push(syms);
        }
        return result;
    }

    findSymbolsWithPrefix(prefix : string, allowSymbols : DBAllowSymbol = DBAllowSymbol.All, caseSensitive = true) : Array<DBSymbol> | null
    {
        if (prefix.length < 2)
            return null;

        let result = [];
        let charPrefix = prefix.substring(0, 2).toLowerCase();
        let syms = this.symbolsByPrefix.get(charPrefix);
        if (syms && syms.length != 0)
        {
            for (let sym of syms)
            {
                if (!FilterAllowsSymbol(sym, allowSymbols))
                    continue;

                if (caseSensitive)
                {
                    if (sym.name.startsWith(prefix))
                        result.push(sym);
                }
                else
                {
                    if (sym.name.toLowerCase().startsWith(prefix.toLowerCase()))
                        result.push(sym);
                }
            }
        }

        return result;
    }

    findChildNamespace(name : string) : DBNamespace | null
    {
        let childNamespace = this.childNamespaces.get(name);
        return childNamespace;
    }

    findChildNamespacesWithPrefix(prefix : string, caseSensitive = true) : Array<DBNamespace>
    {
        if (prefix.length < 2)
            return null;

        let result = new Array<DBNamespace>();
        let charPrefix = prefix.substring(0, 2).toLowerCase();
        let namespaces = this.childNamespacesByPrefix.get(charPrefix);
        if (namespaces && namespaces.length != 0)
        {
            for (let ns of namespaces)
            {
                if (caseSensitive)
                {
                    if (ns.name.startsWith(prefix))
                        result.push(ns);
                }
                else
                {
                    if (ns.name.toLowerCase().startsWith(prefix.toLowerCase()))
                        result.push(ns);
                }
            }
        }

        return result;
    }

    addSymbol(symbol : DBSymbol)
    {
        symbol.containingType = null;
        symbol.namespace = this;

        {
            let syms = this.symbols.get(symbol.name);
            if (!syms)
            {
                this.symbols.set(symbol.name, symbol);
            }
            else if (syms instanceof Array)
            {
                syms.push(symbol);
            }
            else
            {
                this.symbols.set(symbol.name, [symbol, syms]);
            }
        }

        if (symbol.name.length > 2)
        {
            let prefix = symbol.name.substring(0, 2).toLowerCase();
            let prefixSyms = this.symbolsByPrefix.get(prefix);
            if (!prefixSyms)
            {
                prefixSyms = new Array<DBSymbol>();
                this.symbolsByPrefix.set(prefix, prefixSyms);
            }

            prefixSyms.push(symbol);
        }
    }

    removeSymbol(symbol : DBSymbol, modulename?: string)
    {
        let removedAny = false;
        {
            let syms = this.symbols.get(symbol.name);
            if (syms)
            {
                if (syms == symbol)
                {
                    if (symbol.declaredModule == modulename) {
                        removedAny = true;
                        this.symbols.delete(symbol.name);
                    }
                }
                else if (syms instanceof Array)
                {
                    let index = syms.indexOf(symbol);
                    if (index != -1) {
                        removedAny = true;
                        syms.splice(index, 1);
                    }
                }
            }
        }

        if (symbol.name.length > 2)
        {
            let prefix = symbol.name.substring(0, 2).toLowerCase();
            let prefixSyms = this.symbolsByPrefix.get(prefix);
            if (prefixSyms)
            {
                let index = prefixSyms.indexOf(symbol);
                if (index != -1)
                    prefixSyms.splice(index, 1);
            }
        }
        return removedAny;
    }

    addChildNamespace(childNS : DBNamespace)
    {
        childNS.parentNamespace = this;
        this.childNamespaces.set(childNS.name, childNS);
        NamespacesByFullName.set(childNS.getQualifiedNamespace(), childNS);

        if (childNS.name.length > 2)
        {
            let prefix = childNS.name.substring(0, 2).toLowerCase();
            let prefixSyms = this.childNamespacesByPrefix.get(prefix);
            if (!prefixSyms)
            {
                prefixSyms = new Array<DBNamespace>();
                this.childNamespacesByPrefix.set(prefix, prefixSyms);
            }

            prefixSyms.push(childNS);
        }
    }

    removeChildNamespace(childNS : DBNamespace)
    {
        let existingChild = this.childNamespaces.get(childNS.name);
        if (existingChild == childNS)
            this.childNamespaces.delete(childNS.name);

        let existingNS = NamespacesByFullName.get(childNS.getQualifiedNamespace());
        if (existingNS == childNS)
        {
            NamespacesByFullName.delete(childNS.getQualifiedNamespace());
        }

        childNS.parentNamespace = null;
        childNS.qualifiedNamespace = null;

        if (childNS.name.length > 2)
        {
            let prefix = childNS.name.substring(0, 2).toLowerCase();
            let prefixSyms = this.childNamespacesByPrefix.get(prefix);
            if (prefixSyms)
            {
                let index = prefixSyms.indexOf(childNS);
                if (index != -1)
                    prefixSyms.splice(index, 1);
            }
        }
    }

    addScriptDeclaration(decl : DBNamespaceDeclaration)
    {
        this.declarations.push(decl);
    }

    removeScriptDeclarations(moduleName : string)
    {
        for (let i = this.declarations.length - 1; i >= 0; --i)
        {
            if (this.declarations[i].declaredModule == moduleName)
                this.declarations.splice(i, 1);
        }
    }

    removeSymbolsDeclaredIn(declaredModule : string, removeSymbols = DBAllowSymbol.All)
    {
        let oldSymbols = this.symbols;

        this.symbols = new Map<string, DBSymbol | Array<DBSymbol>>();
        this.symbolsByPrefix = new Map<string, Array<DBSymbol>>();

        for (let [_, syms] of oldSymbols)
        {
            if (syms instanceof Array)
            {
                for (let sym of syms)
                {
                    if (sym.declaredModule == declaredModule && FilterAllowsSymbol(sym, removeSymbols))
                        continue;
                    this.addSymbol(sym);
                }
            }
            else
            {
                if (syms.declaredModule == declaredModule && FilterAllowsSymbol(syms, removeSymbols))
                    continue;
                this.addSymbol(syms);
            }
        }
    }

    getDeclarationInModule(declaredModule : string) : DBNamespaceDeclaration | null
    {
        for (let decl of this.declarations)
        {
            if (decl.declaredModule == declaredModule)
                return decl;
        }
        return null;
    }

    getFirstScriptDeclaration() : DBNamespaceDeclaration | null
    {
        for (let decl of this.declarations)
        {
            if (decl.declaredModule)
                return decl;
        }
        return null;
    }

    getCppDeclaration() : DBNamespaceDeclaration | null
    {
        for (let decl of this.declarations)
        {
            if (decl.declaredModule === null)
                return decl;
        }
        return null;
    }
};


export class DBAccessSpecifier
{
    name : string;
    declaredType : string;
    isDeclared : boolean = false;

    isPrivate : boolean = false;
    isProtected : boolean = false;

    bAnyReadOnly : boolean = false;
    bAnyEditDefaults : boolean = false;

    permissions : Array<DBAccessPermission>;

    declaredModule : string;
    moduleOffset : number;
    moduleOffsetEnd : number = -1;

    getAccess(fromType : DBType, fromFunction : DBMethod) : [boolean, boolean, boolean]
    {
        if (fromType == null && fromFunction == null)
            return [this.bAnyReadOnly, false, this.bAnyEditDefaults];

        if (fromType)
        {
            if (this.isProtected)
            {
                if (fromType.inheritsFrom(this.declaredType))
                    return [true, true, true];
            }
            else
            {
                if (fromType.name == this.declaredType)
                    return [true, true, true];
            }
        }

        let read = false;
        let write = false;
        let edit = false;

        if (this.bAnyEditDefaults)
            edit = true;
        if (this.bAnyReadOnly)
            read = true;

        if (this.permissions)
        {
            for (let cls of this.permissions)
            {
                let clsApplies = false;

                if (fromType)
                {
                    if (cls.bInherited)
                        clsApplies = fromType.inheritsFrom(cls.accessName);
                    else
                        clsApplies = (fromType.name == cls.accessName);
                }
                else if (fromFunction)
                {
                    clsApplies = (fromFunction.name == cls.accessName);
                }

                if (clsApplies)
                {
                    if (cls.bReadOnly)
                    {
                        read = true;

                        if (cls.bEditDefaults)
                            edit = true;
                    }
                    else
                    {
                        if (cls.bEditDefaults)
                        {
                            edit = true;
                        }
                        else
                        {
                            read = true;
                            edit = true;
                            write = true;
                        }
                    }
                }
            }
        }

        return [read, write, edit];
    }
};

export class DBAccessPermission
{
    accessName : string;
    bInherited : boolean = false;
    bReadOnly : boolean = false;
    bEditDefaults : boolean = false;
};

let DirtyTypeCacheId = 0;
export function OnDirtyTypeCaches()
{
    DirtyTypeCacheId++;
}

let UnrealTypesLoaded = false;
let RootNamespace = new DBNamespace;
let TypesById = new Map<number, DBType>();
let NamespacesByFullName = new Map<string, DBNamespace>([["", RootNamespace]]);
let TypesByName = new Map<string, DBType | Array<DBType>>();

let NextMethodId = 1;
let NextTypeId = 1;

export function CleanTypeName(typename : string) : string
{
    if (typename.startsWith("const "))
        typename = typename.trim().substring(6);
    if (typename.endsWith("&"))
        typename = typename.trim().substring(0, typename.length-1);
    else if (typename.endsWith("&out"))
        typename = typename.trim().substring(0, typename.length-4);
    else if (typename.endsWith("&in"))
        typename = typename.trim().substring(0, typename.length-3);
    else if (typename.endsWith("&inout"))
        typename = typename.trim().substring(0, typename.length-6);
    else if (typename.endsWith("@"))
        typename = typename.trim().substring(0, typename.length-1);
    return typename;
}

export function StripNamespaceFromTypeName(typename: string): string {
    let parts = typename.split("::");
    return parts[parts.length - 1];
}

export function TypenameEquals(left : string, right : string) : boolean
{
    return CleanTypeName(left) == CleanTypeName(right);
}

export function TransferTypeQualifiers(typename : string, newtype : string) : string
{
    if (typename.startsWith("const "))
        newtype = "const "+newtype;
    if (typename.endsWith("&"))
        newtype = newtype+"&";
    else if (typename.endsWith("&out"))
        newtype = newtype+"&out";
    else if (typename.endsWith("&in"))
        newtype = newtype+"&in";
    else if (typename.endsWith("&inout"))
        newtype = newtype+"&inout";
    return newtype;
}

let re_template = /([A-Za-z_0-9]+)\<(([A-Za-z_0-9:]+\s*(<[A-Za-z_0-9:,\s]+>)?,?)+)@?\>/;
export function ReplaceTemplateType(typename : string, templateTypes : Array<string>, actualTypes : Array<string>)
{
    typename = CleanTypeName(typename);
    for (let i = 0; i < templateTypes.length; ++i)
    {
        if (typename == templateTypes[i])
        {
            return actualTypes[i];
        }
    }

    if (typename.indexOf('<') != -1)
    {
        // Replace the template types inside the subtemplate as well
        let match = typename.match(re_template);
        if (match != null)
        {
            let basetype = match[1];

            let newtype = "";
            for (let subtype of match[2].split(","))
            {
                subtype = subtype.trim();
                let templIndex = templateTypes.indexOf(subtype);
                if (templIndex != -1)
                    subtype = actualTypes[templIndex];
                if (newtype.length != 0)
                    newtype += ",";
                newtype += subtype;
            }

            return basetype+"<"+newtype+">";
        }
    }

    return typename;
}

export function GetTypeByName(typename : string, inNamespace?: string) : DBType | null
{
    // console.log(`GetTypeByName: ${typename} w/ ns: ${inNamespace}`);
    let found = TypesByName.get(typename);
    if (found instanceof Array) {
        if (inNamespace) {
            // exact match of namespace
            for (let _found of found) {
                // console.log(`_found.namespace: ${_found.namespace.getQualifiedNamespace()}`);
                if (_found.namespace.getQualifiedNamespace() == inNamespace)
                   return _found;
            }
            // didn't find an exact match, try looser
            for (let _found of found) {
                if (_found.namespace.getQualifiedNamespace().includes(inNamespace))
                    return _found;
            }
        }
        // console.trace(`Found multiple types under the name: ${inNamespace || ''}::${typename}. Namespaces: ${found.map(v => v.namespace.getQualifiedNamespace()).join(", ")}`);
        return found[0]; // return first b/c we can't really do more
    }
    return found;
}

export function GetTypeById(typeid : number) : DBType | null
{
    return TypesById.get(typeid);
}

export function GetAllTypesById() : Map<number, DBType>
{
    return TypesById;
}

export function GetAllNamespaces() : Map<string, DBNamespace>
{
    return NamespacesByFullName;
}

function SplitNamespace(identifier : string) : Array<string>
{
    return identifier.split("::");
}

export function LookupNamespace(namespace : DBNamespace, name : string) : DBNamespace | null
{
    if (!namespace)
        namespace = RootNamespace;

    if (!name || name.length == 0)
        return namespace;

    let namespaceIndex = name.indexOf("::");
    if (namespaceIndex == -1)
    {
        let checkNamespace = namespace;
        while (checkNamespace)
        {
            let targetNamespace = checkNamespace.findChildNamespace(name);
            if (targetNamespace)
                return targetNamespace;

            checkNamespace = checkNamespace.parentNamespace;
        }

        return null;
    }

    // `::X::Y` -> `X::Y`
    if (namespaceIndex == 0)
    {
        namespace = RootNamespace;
        name = name.substring(2);
    }

    let nameParts = SplitNamespace(name);
    let checkNamespace = namespace;

    while (checkNamespace)
    {
        let targetNamespace = checkNamespace;
        for (let part of nameParts)
        {
            targetNamespace = targetNamespace.findChildNamespace(part.trim());
            if (!targetNamespace)
                break;
        }
        if (targetNamespace)
            return targetNamespace;

        checkNamespace = checkNamespace.parentNamespace;
    }
    console.warn(`Returning nothing for LookupNamespace! ${name}`);
}

export function LookupNamespacesWithPrefix(namespace : DBNamespace, prefix : string, caseSensitive = true) : Array<DBNamespace> | null
{
    if (!namespace)
        namespace = RootNamespace;

    if (!prefix || prefix.length < 2)
        return null;

    let checkNamespace = namespace;
    let result : Array<DBNamespace> = null;
    while (checkNamespace)
    {
        let children = checkNamespace.findChildNamespacesWithPrefix(prefix);
        if (children)
        {
            if (result)
                result = result.concat(children);
            else
                result = children;
        }

        checkNamespace = checkNamespace.parentNamespace;
    }

    return result;
}

export function GetRootNamespace() : DBNamespace
{
    return RootNamespace;
}

export function DeclareNamespace(namespace : DBNamespace, name : string, decl : DBNamespaceDeclaration) : DBNamespace
{
    if (!namespace)
        namespace = RootNamespace;

    let parts = name.split("::");

    let ns = namespace.findChildNamespace(parts[0]);
    if (!ns)
    {
        ns = new DBNamespace();
        ns.name = parts[0];
        ns.parentNamespace = RootNamespace; // will be replaced by addChildNamespace
        namespace.addChildNamespace(ns);
    }
    ns.addScriptDeclaration(decl);

    if (parts.length == 1)
        return ns;

    // more namespaces to declare
    return DeclareNamespace(ns, parts.slice(1).join("::"), decl);
}

export function RemoveNamespaceDeclaration(namespace : DBNamespace, moduleName : string)
{
    namespace.removeScriptDeclarations(moduleName);
    if (namespace.declarations.length == 0 && namespace.parentNamespace)
        namespace.parentNamespace.removeChildNamespace(namespace);
}


export function LookupTypesInheriting(namespace : DBNamespace, typename : string) : DBType[] {
    if (!typename) return [];
    let identifier = CleanTypeName(typename);
    console.log(`Looking up subtypes of: ${typename}`);
    let dbType = (namespace || RootNamespace).GetTypeByName(identifier);
    if (!dbType) dbType = LookupType(namespace, typename);
    console.log(`Found DBType for: ${typename} named: ${dbType?.name}`);
    if (!dbType) return [];
    let ret: DBType[] = [];
    let typeNames = new Set<string>();
    let findSubTypesForNamespace = (ns: DBNamespace) => {
        ns.forEachSymbol(s => {
            if (s instanceof DBType) {
                if ((s.supertype == identifier || s.supertypes?.includes(identifier)) && !typeNames.has(identifier)) {
                    ret.push(s);
                    typeNames.add(identifier);
                }
            } else if (s instanceof DBNamespace) {
                findSubTypesForNamespace(s)
            }
        })
    };
    findSubTypesForNamespace(RootNamespace);
    // all the symbols we just added are novel (and no duplicates) so next we want to find all types that inherit these types,
    // and add them to the return, too. (deduping along the way).
    let ret2 = ret.flatMap(s => {
        let extraTypes = LookupTypesInheriting(s.namespace, s.name);
        return extraTypes.filter(t => !typeNames.has(t.name));
    })
    ret2.forEach(s => {
        if (!typeNames.has(s.name)) {
            ret.push(s);
            typeNames.add(s.name);
        }
    });
    return ret;
}

export function LookupType(namespace : DBNamespace, typename : string) : DBType | null
{
    if (!typename)
        return null;
    let identifier = CleanTypeName(typename);

    if (namespace) {
        // console.warn(`checking namespace: ${namespace.name}`)
        let found = namespace.GetTypeByName(identifier);
        if (found && !(found instanceof Array)) {
            if (found.namespace != namespace)
                console.warn(`Unexpected mismatching namespaces (identifier: ${identifier}): ${found.namespace.getQualifiedNamespace()} vs ${namespace.getQualifiedNamespace()}`)
            return found;
        }
    }

    let namespaceIndex = identifier.indexOf("::");
    if (namespaceIndex == -1)
    {
        let found = TypesByName.get(identifier);
        let wasArray = found instanceof Array;
        if (found instanceof Array) {
            // console.trace(`skipping over multiple types (${namespace?.getQualifiedNamespace()}::${identifier}) in namespaces: ${found.map(t => t.namespace.getQualifiedNamespace()).join(', ')}`)
            found = found[0];
        }

        if (found)
        {
            if (!namespace || !found.namespace || namespace == found.namespace || namespace.isChildNamespaceOf(found.namespace)) {
                // if (wasArray) console.log(`returning positive match for ${namespace?.getQualifiedNamespace()}::${identifier}`)
                return found;
            }
            if (wasArray) {
                // console.log(`did not find match for ${namespace?.getQualifiedNamespace()}::${identifier}`)
            }
        }
    }
    else
    {
        if (!namespace)
            namespace = RootNamespace;

        if (namespaceIndex == 0)
        {
            namespace = RootNamespace;
            identifier = identifier.substring(2);
        }

        let nameParts = SplitNamespace(identifier);
        let finalIdentifier = nameParts[nameParts.length - 1];

        let checkNamespace = namespace;
        let loopCount = 0;
        while (checkNamespace)
        {
            let targetNamespace = checkNamespace;
            for (let i = 0, count = nameParts.length - 1; i < count; ++i)
            {
                targetNamespace = targetNamespace.findChildNamespace(nameParts[i].trim());
                if (!targetNamespace)
                    break;
            }
            if (targetNamespace)
            {
                let type = targetNamespace.findFirstSymbol(finalIdentifier, DBAllowSymbol.Types);
                if (type instanceof DBType)
                    return type;
            }

            checkNamespace = checkNamespace.parentNamespace;
            loopCount++;
            if (loopCount > 10) console.log(`checkNamespace loopCount: ${loopCount}`)
        }
    }

    // See if we have to create a template instance
    if (identifier.indexOf('<') != -1)
    {
        // console.log(`template instance, checked identifier: ${identifier}`)
        let match = identifier.match(re_template);
        if (match != null)
        {
            let basetype = match[1];
            let _subtypes = match[2].split(",").map(s => s.trim());
            let subtypeVariants = [_subtypes];
            // let hasNsInType = _subtypes.filter(s => s.includes("::")).length > 0;
            // if (hasNsInType) subtypeVariants.push(_subtypes.map(StripNamespaceFromTypeName));
            // if (namespace) subtypeVariants.push(_subtypes.map(StripNamespaceFromTypeName).map(s => namespace.getQualifiedNamespace() + "::" + s))

            let mainInst;
            for (let subtypes of subtypeVariants) {
                let dbbasetype = LookupType(namespace, basetype);
                if (!dbbasetype)
                return null;

                let inst = dbbasetype.createTemplateInstance(subtypes);
                if (!inst) return null;
                inst.name = identifier;
                if (!inst) return null;
                if (!mainInst) mainInst = inst;

                // console.log(`adding to database: ${namespace.name}::${inst.getDisplayName()}`)
                AddTypeToDatabase(namespace, inst);
            }
            return mainInst;
        }
    }

    return null;
}

export function LookupGlobalSymbol(namespace : DBNamespace, name : string, allowSymbol = DBAllowSymbol.All) : Array<DBSymbol>
{
    if (!name)
        return [];

    let identifier = name;
    if (!namespace)
        namespace = RootNamespace;

    let result : Array<DBSymbol> = null;
    let namespaceIndex = identifier.indexOf("::");
    if (namespaceIndex == -1)
    {
        let checkNamespace = namespace;
        while (checkNamespace)
        {
            let symbols = checkNamespace.findSymbols(identifier, allowSymbol);
            if (symbols)
            {
                if (result)
                    result = result.concat(symbols);
                else
                    result = symbols;
            }

            checkNamespace = checkNamespace.parentNamespace;
        }

        return result;
    }

    if (namespaceIndex == 0)
    {
        namespace = RootNamespace;
        identifier = identifier.substring(2);
    }

    let nameParts = SplitNamespace(identifier);
    let finalIdentifier = nameParts[nameParts.length - 1];

    let checkNamespace = namespace;
    while (checkNamespace)
    {
        let targetNamespace = checkNamespace;
        for (let i = 0, count = nameParts.length - 1; i < count; ++i)
        {
            targetNamespace = targetNamespace.findChildNamespace(nameParts[i].trim());
            if (!targetNamespace)
                break;
        }
        if (targetNamespace)
        {
            let symbols = targetNamespace.findSymbols(finalIdentifier, allowSymbol);
            if (symbols)
            {
                if (result)
                    result = result.concat(symbols);
                else
                    result = symbols;
            }
        }

        checkNamespace = checkNamespace.parentNamespace;
    }

    return result;
}

export function LookupGlobalSymbolsWithPrefix(namespace : DBNamespace, prefix : string, allowSymbol = DBAllowSymbol.All, caseSensitive = true) : Array<DBSymbol>
{
    if (!prefix || prefix.length < 2)
        return [];

    if (!namespace)
        namespace = RootNamespace;

    if (!namespace)
        namespace = RootNamespace;

    let result : Array<DBSymbol> = null;
    let checkNamespace = namespace;
    while (checkNamespace)
    {
        let symbols = checkNamespace.findSymbolsWithPrefix(prefix, allowSymbol, caseSensitive);
        if (symbols)
        {
            if (result)
                result = result.concat(symbols);
            else
                result = symbols;
        }

        checkNamespace = checkNamespace.parentNamespace;
    }

    return result;
}

export function HasTypeWithPrefix(namespace : DBNamespace, typenamePrefix : string, caseSensitive = true) : boolean
{
    if (!typenamePrefix || typenamePrefix.length < 2)
        return true;

    if (!namespace)
        namespace = RootNamespace;

    let checkNamespace = namespace;
    while (checkNamespace)
    {
        let symbols = checkNamespace.findSymbolsWithPrefix(typenamePrefix, DBAllowSymbol.Types, caseSensitive);
        if (symbols && symbols.length != 0)
            return true;

        checkNamespace = checkNamespace.parentNamespace;
    }

    return false;
}

export function IsPrimitive(typename : string) : boolean
{
    let type = LookupType(null, typename);
    if (!type)
        return false;
    return type.isPrimitive;
}

function GetTypenameCharPrefix(typename : string) : string
{
    if (typename.length < 2)
        return null;
    return typename.substring(0, 2).toLowerCase();
}

let DatabaseFloatIsFloat64 = false;
let PrimitiveAliases = new Map<string, string>();

export function AddPrimitiveTypes(floatIsFloat64 : boolean)
{
    DatabaseFloatIsFloat64 = floatIsFloat64;

    PrimitiveAliases.clear();
    PrimitiveAliases.set("int", "int32");
    PrimitiveAliases.set("int32", "int32");
    PrimitiveAliases.set("int64", "int64");
    PrimitiveAliases.set("uint", "uint32");
    PrimitiveAliases.set("uint32", "uint32");
    PrimitiveAliases.set("uint64", "uint64");
    PrimitiveAliases.set("int8", "int8");
    PrimitiveAliases.set("uint8", "uint8");
    PrimitiveAliases.set("int16", "int16");
    PrimitiveAliases.set("uint16", "uint16");
    PrimitiveAliases.set("bool", "bool");
    // PrimitiveAliases.set("string", "string");
    // PrimitiveAliases.set("wstring", "wstring");
    // PrimitiveAliases.set("vec2", "vec2");
    // PrimitiveAliases.set("vec3", "vec3");
    // PrimitiveAliases.set("vec4", "vec4");

    if (DatabaseFloatIsFloat64)
        PrimitiveAliases.set("float", "float64");
    else
        PrimitiveAliases.set("float", "float32");

    PrimitiveAliases.set("float32", "float32");
    PrimitiveAliases.set("float64", "float64");
    PrimitiveAliases.set("double", "float64");

    for (let [primtype, alias] of PrimitiveAliases)
    {
        let dbtype = new DBType().initEmpty(primtype);
        dbtype.isPrimitive = true;
        AddOpenplanetTypeToDatabase(null, dbtype);
        AddOpenplanetFunction({
            name: primtype,
            returntypedecl: primtype,
            args: [{name: "value", typedecl: "?"}],
            decl: `${primtype} ${primtype}(?)`,
            desc: `Cast a primitive type to a ${primtype}`,
            ns: ""
        });
    }
}

export function ArePrimitiveTypesEquivalent(typenameA : string, typenameB : string) : boolean
{
    let aliasA = PrimitiveAliases.get(typenameA);
    let aliasB = PrimitiveAliases.get(typenameB);
    return (aliasA && aliasB && aliasA == aliasB);
}

export function IsPrimitiveFloatType(typename : string) : boolean
{
    let realType = PrimitiveAliases.get(typename);
    return realType == "float32" || realType == "float64";
}

let NadeoTypeCounter = new TypeCounter();

export function AddNadeoTypesFromOpenplanet(input: any) {
    // let enums: Array<> = [];
    let isJsonV2 = 'op' in input;
    for (let k in input['ns']) { // k is a namespace, but it's not used in angelscript, only docs
        for (let ty in input['ns'][k]) {
            let tyDeets = input['ns'][k][ty];
            let nadeoClassTy = ConvertNadeoType(ty, tyDeets, k, isJsonV2);
            AddOpenplanetClass(nadeoClassTy, "classes");
            NadeoTypeCounter.CountType("class");
            NadeoTypeCounter.CountType("method", nadeoClassTy.methods?.length);
            NadeoTypeCounter.CountType("property", nadeoClassTy.props?.length);
            nadeoClassTy.enums?.forEach(e => {
                AddOpenplanetClass(e, "enums");
                NadeoTypeCounter.CountType("enum");
            })
        }
    }
    console.log(`AddNadeoTypes: ${NadeoTypeCounter.ToString()}`)
}

export function AddOpenplanetFunction(jData: any) {
    let func = new DBMethod();
    func.fromJSON(jData);
    let ns = RootNamespace;
    if (func.ns) {
        let decl = new DBNamespaceDeclaration();
        ns = LookupNamespace(null, func.ns);
        if (!ns) {
            ns = DeclareNamespace(null, func.ns, decl);
        }
    }
    // todo: AddOpenplanetTypeToDatabase?
    ns.addSymbol(func);
}

export function ConvertOpenplanetConstructorsToMethods(name: string, ns: string, desc: string, behaviors: any): DBMethod[] {
    let methods: DBMethod[] = [];
    if (!ns) ns = "";
    if (!behaviors || !name) return methods;
    for (let behavior of behaviors) {
        if (behavior.type === 0 || behavior.type === 3) {
            let constructor = new DBMethod()
            let bTy = behavior.type;
            constructor.fromJSON({
                ...behavior.func,
                name,
                desc,
                returntypedecl: bTy === 3 ? (behavior.func.returntypedecl) : name, //  as string).replace(`${ns}::`, ''
            })
            methods.push(constructor);
        }
    }
    return methods;
}

const OpenplanetTemplateTypes =
        ["array", "MwSArray", "MwFastArray", "MwStridedArray", "MwFastBuffer", "MwNodPool", "MwRefBuffer"];
let OpenplanetTemplateTypeMap: Map<string, string> = new Map();
OpenplanetTemplateTypes.forEach(t => OpenplanetTemplateTypeMap.set(t, t + "<T>"));

export function AddOpenplanetClass(jData: any, kind: "classes" | "enums") {
    let hasSubtype = OpenplanetTemplateTypeMap.has(jData['name']);
    if (hasSubtype) {
        // jData['name'] = OpenplanetTemplateTypeMap.get(jData['name']);
        jData['subtypes'] = ["T"];
    }

    let constructors = ConvertOpenplanetConstructorsToMethods(jData['name'], jData.ns, jData.desc || "", jData.behaviors);

    let type = new DBType(kind);
    type.fromJSON(jData);

    let isVecIsh = ["vec", "int", "iso", "nat", "mat"].includes(type.name.substring(0, 3)) && type.name.length == 4;
    isVecIsh ||= type.name == "quat";
    let isArrayIsh = type.name == "array<T>" || type.name == "MwFastBuffer<T>";
    if (isVecIsh || isArrayIsh) type.isPrimitive = true; // don't autosuggest @ references for types

    let ns = RootNamespace;
    if (type.ns) {
        let ns2 = LookupNamespace(ns, type.ns);
        if (!ns2) {
            let decl = new DBNamespaceDeclaration();
            ns2 = DeclareNamespace(ns, type.ns, decl);
            console.log(`Declared namespace: ${type.ns}`);
        } else {
            console.log(`Detected namespace: ${type.ns}, Q: ${ns.qualifiedNamespace}`);
        }
        ns2.addSymbol(type);
        // if (kind == "enums") console.warn(`added enum to namespace: ${type.namespace.getQualifiedNamespace()} :: ${type.name}`)
    }
    constructors.forEach(m => ns.addSymbol(m)); // add to global namespace too, not just a nonglobal one
    if (type.isEnum || !type.ns) {
        AddTypeToDatabase(ns, type);
    }

    return type;
}


/* openplanet constructor/destructor notes:
    {type: 0|2, func: {...}}
    - $beh2, type: 2
        - destructor? (IO::File)
    - $beh0, type: 0
        - constructor? (IO::File)
        - can have args / be overloaded
    - $beh5|$beh6, type 5|6 ?? (SQLite::Statement)
        - no documentation on op.dev
        - same for Discord::User
        - same for nvg::Texture
    - $beh3, type 3 ?? (SQLite::Database)
        - normal constructor?
        - has args and stuff
    - array types 0|2|4
        - also has type: 5|6|9|10|11|12|13|8|4
        - bool $beh8(int&in, bool&out) -- doesn't correspond to docs
        - type 4: "T[]@ $list(int&in type, int&in list) { repeat T }"
    - dictionaryValue
      - types 12|13 not used
    - dictionary, types: 3|5|6|9|10|11|12|13|4
    - ref: 12|13
    - MemoryBuffer: 3|5|6
        - lots of decls nuder 3, eg: "decl": "MemoryBuffer@ MemoryBuffer(uint64 size, uint8 init)"
*/

let OpenplanetTypeCounter = new TypeCounter();

export function AddTypesFromOpenplanet(input : any)
{
    for (let key in input["functions"]) {
        let jData = input["functions"][key];
        AddOpenplanetFunction(jData);
        OpenplanetTypeCounter.CountType("function")
    }
    const kinds: ("classes" | "enums")[] = ["classes", "enums"];
    kinds.forEach((kind) => {
        input[kind].forEach((jData: any) => {
            let dbtype = AddOpenplanetClass(jData, kind);
            OpenplanetTypeCounter.CountType(kind)
            dbtype.forEachSymbol(s => {
                if (s instanceof DBMethod) OpenplanetTypeCounter.CountType("method")
                else if (s instanceof DBProperty) OpenplanetTypeCounter.CountType("property")
            })
        });
    });
    console.log(`AddOpenplanetTypes: ${OpenplanetTypeCounter.ToString()}`);
}

export function AddOpenplanetIcons() {
    let iconsNs = DeclareNamespace(null, "Icons", new DBNamespaceDeclaration());
    let iconsKenneyNs = DeclareNamespace(iconsNs, "Kenney", new DBNamespaceDeclaration());
    IconNames.map(n => {
        let prop = new DBProperty();
        let _nParts = n.split("::");
        n = _nParts[_nParts.length - 1];
        let isKenney = _nParts.length > 1; // only alt to Icons namespace itself
        prop.fromJSON({name: n, typedecl: "string"});
        prop.isNoEdit = true;
        let ns = isKenney ? iconsKenneyNs : iconsNs;
        ns.addSymbol(prop);
    });
}

export function AddOpenplanetConstants() {
    let ns = LookupNamespace(null, "Math");
    if (!ns) {
        ns = DeclareNamespace(null, "Math", new DBNamespaceDeclaration());
    }
    let prop = new DBProperty();
    prop.fromJSON({name: "PI", typedecl: "float"});
    prop.isNoEdit = true;
    ns.addSymbol(prop);
}

export function AddOpenplanetFuncdefs() {
    let funcdefs = [
        {
            name: "CoroutineFunc",
            returntypedecl: "void",
            args: []
        },
        {
            name: "CoroutineFuncUserdata",
            returntypedecl: "void",
            args: [{name: "userdata", typedecl: "ref@"}]
        },
        {
            name: "CoroutineFuncUserdataInt64",
            returntypedecl: "void",
            args: [{name: "userdata", typedecl: "const int64"}]
        },
        {
            name: "CoroutineFuncUserdataInt64",
            returntypedecl: "void",
            args: [{name: "userdata", typedecl: "const int"}]
        },
        {
            name: "CoroutineFuncUserdataUint64",
            returntypedecl: "void",
            args: [{name: "userdata", typedecl: "const uint"}]
        },
        {
            name: "CoroutineFuncUserdataUint64",
            returntypedecl: "void",
            args: [{name: "userdata", typedecl: "const uint64"}]
        },
        {
            name: "CoroutineFuncUserdataDouble",
            returntypedecl: "void",
            args: [{name: "userdata", typedecl: "const double"}]
        },
        {
            name: "CoroutineFuncUserdataString",
            returntypedecl: "void",
            args: [{name: "userdata", typedecl: "const string &in"}]
        },
        {
            name: "ProcIntercept",
            returntypedecl: "bool",
            args: [{name: "stack", typedecl: "CMwStack &in"}]
        },
        {
            name: "ProcInterceptEx",
            returntypedecl: "bool",
            args: [{name: "stack", typedecl: "CMwStack &in"}, {name: "nod", typedecl: "CMwNod@"}]
        },
        {
            ns: "UI",
            name: "InputTextCallback",
            returntypedecl: "void",
            args: [{name: "data", typedecl: "UI::InputTextCallbackData@"}]
        },
        {
            ns: "UI",
            name: "NodTreeMemberCallback",
            returntypedecl: "void",
            args: [{name: "nod", typedecl: "CMwNod@"}, {name: "info", typedecl: "Reflection::MwMemberInfo@"}]
        },
    ]
    funcdefs.forEach(fd => {
        let method = new DBMethod;
        method.fromJSON(fd);
        // method.namespace.addSymbol(method.getFuncType());
        method.getFuncType(); // adds to db if it doesn't exist
        method.namespace.addSymbol(method.asFuncDefApplier());
    })
}

// export function FinishTypesFromUnreal()
// {
//     UnrealTypesLoaded = true;

//     // Some hardcoded extra information we want to add to unreal functions
//     let systemLib = RootNamespace.findChildNamespace("System");
//     if (systemLib)
//     {
//         for (let functionName of [
//             "SetTimer", "ClearTimer", "PauseTimer", "UnPauseTimer",
//             "IsTimerActive", "IsTimerPaused", "TimerExists",
//             "GetTimerElapsedTime", "GetTimerRemainingTime"
//         ])
//         {
//             let timerFunc = systemLib.findFirstSymbol(functionName, DBAllowSymbol.Functions);
//             if (timerFunc instanceof DBMethod)
//             {
//                 timerFunc.isDelegateBindFunction = true;
//                 timerFunc.delegateBindType = "FTimerDynamicDelegate";
//                 timerFunc.delegateObjectParam = 0;
//                 timerFunc.delegateFunctionParam = 1;
//             }
//         }
//     }

//     // Annotate linear color creation functions
//     let linearColorConstructors = RootNamespace.findSymbols("FLinearColor", DBAllowSymbol.Functions);
//     for (let method of linearColorConstructors)
//     {
//         if (method instanceof DBMethod)
//             method.methodAnnotation = DBMethodAnnotation.IsLinearColor;
//     }

//     let linearColorNS = RootNamespace.findChildNamespace("FLinearColor");
//     if (linearColorNS)
//     {
//         let fromHexFunction = linearColorNS.findFirstSymbol("MakeFromHex", DBAllowSymbol.Functions);
//         if (fromHexFunction instanceof DBMethod)
//             fromHexFunction.methodAnnotation = DBMethodAnnotation.IsHexColor;
//     }
// }

export function AddTypeToDatabase(namespace : DBNamespace, dbtype : DBType)
{
    if (!namespace)
        namespace = RootNamespace;

    dbtype.namespace = namespace;
    dbtype.typeid = NextTypeId++;

    namespace.addSymbol(dbtype);
    TypesById.set(dbtype.typeid, dbtype);

    let found = TypesByName.get(dbtype.name);
    if (!found)
        TypesByName.set(dbtype.name, dbtype);
    else if (found instanceof Array)
        found.splice(0, 0, dbtype);
    else
        TypesByName.set(dbtype.name, [dbtype, found]);

    OnDirtyTypeCaches();
}


export function AddOpenplanetTypeToDatabase(namespace : DBNamespace, dbtype : DBType)
{
    if (!namespace)
        namespace = RootNamespace;

    let existingTypes = namespace.findSymbols(dbtype.name, DBAllowSymbol.Types);
    for (let previousType of existingTypes)
    {
        if (previousType instanceof DBType)
        {
            if (!previousType.declaredModule)
                RemoveTypeFromDatabase(previousType);
        }
    }

    AddTypeToDatabase(namespace, dbtype);
}

export function RemoveTypeFromDatabase(dbtype : DBType, modulename?: string)
{
    if (!dbtype.namespace)
        return;

    let didRemoveFromNS = dbtype.namespace.removeSymbol(dbtype, modulename);
    dbtype.namespace = null;
    // console.trace(`RemoveTypeFromDatabase: ${dbtype.getDisplayName()} -- removed? ${didRemoveFromNS}`)

    TypesById.delete(dbtype.typeid);

    let found = TypesByName.get(dbtype.name);
    if (found == dbtype)
    {
        TypesByName.delete(dbtype.name);
    }
    else if (found instanceof Array)
    {
        let index = found.indexOf(dbtype);
        if (index != -1)
        {
            found.splice(index, 1);
            if (found.length == 1)
                TypesByName.set(dbtype.name, found[0]);
            else if (found.length == 0)
                TypesByName.delete(dbtype.name);
        }
    }

    OnDirtyTypeCaches();
}

let re_comment_star_start = /^[ \t]*\*+([ \t]|\r?\n)/gi;
let re_comment_star_end = /[\r\n]+[ \t]*\*+[ \t]*/gi;
export function FormatDocumentationComment(doc : string) : string
{
    doc = doc.replace(re_comment_star_end, "\n");
    doc = doc.replace(re_comment_star_start, " ");
    doc = doc.trim();
    return doc;
}
